### 笔记

```
ROMS算法的细节核心东西进行阐述 -> 引出移植中的问题

X86架构和ARM架构的差异  -> 导致的移植问题

系统架构存在的问题
程序存在的问题


数据
程序分成模块
运算过程


典型的有美国Marvell公司制造的ThundeX2、安培的eMAG、日本富士通设计的A64FX和中国华为研发的鲲鹏920芯片。国际上已有多个项目将ARM处理器应用于HPC高端系统，例如欧洲巴塞罗那超算中心（BSC）的勃朗峰（Mont-Blanc）项目和亚洲日本的Post-K等。

X86 CPU和ARM CPU的区别有以下几个方面：
（1）体系结构的差异。X86 CPU采用冯诺依曼体系结构，数据和程序存储在同一个存储器中，指令和数据使用相同的总线访问，无法实现同时取指令和取数据，总线访问成为系统的瓶颈。ARM的CPU除了ARM7采用冯诺依曼体系结构外，后面的产品都采用哈佛体系结构。程序和数据采用各自独立的存储器，指令和数据有各自的总线，在处理器高速运行时，大大提高了存储器带宽，提高了访问速度。
（2）寄存器使用的差异。X86 CPU 的可编程寄存器分为通用寄存器和专用寄存器两大类，其中，通用寄存器包括：AX，BX，CX，DX，SI，DI，BP，SP；专业寄存器包括：FLAGS，IP，CS，SS，DS，ES，每个寄存器都有各自特定的功能，名称也是特定功能英文的缩写。ARM CPU内部拥有的寄存器较多，共有37个寄存器，其中，31个为通用寄存器，6个为特殊功能寄存器，即状态寄存器。尽管寄存器较多，但是寄存器的命名很有规律，通用寄存器R0~R15，除了 R13 作为堆栈指针，R14 作为程序链接寄存器，R15 作为程序计数器外，其他的寄存器在使用上没有特殊要求。状态寄存器为 CPSR 和 SPSR，SPSR 为 CPSR 的备份，旨在提高异常发生时的响应速度。主要使用的CPSR 与 X86 CPU 类似，也是按位来使用的，分为状态标志（条件码标志）和控制标志，在状态标志中只保留了常用的NZCV这4位，去掉了使用频率较低的PF和 AF。控制标志中同样包括中断禁止位，但是由于ARM内核有2个中断（IRQ和FIQ）所以有2位中断禁止位，由于ARM内核有2种指令状态，因此增加了指令状态位，ARM 内核有 7 种工作模式，又增加了五位模式位，可以方便进行CPU模式的切换。
（3）寻址方式的差异。X86 采用复杂指令集（CISC 指令集），所有指令都可以访问存储器，指令不是等长的，执行的时间也不是等长的，对旧的指令集有很好的兼容性，从而使指令的解码系统越来越复杂。而 ARM 是采用精简指令集（RISC 指令集），只有 load/store 指令可以访问存储器，其他指令是不能访问存储器的，指令是等长的，大部分算术运算和逻辑运算指令都是单周期执行，执行效率较高。对于堆栈和数组的访问方式差异较大：X86只能一个数据接一个数据地入栈和出栈，在访问连续存储空间时也只能以间接寻址的方式一个数据接一个数据地读或写，程序必须手动更新指针寄存器的值，效率较低。而ARM对于堆栈和数组这类连续存储的存储器空间都可以批量访问，最多可以使用16个寄存器进行数据读和写，即 16×32 位的数据同时入栈或出栈，16×32位的数据同时从数组中批量次地读或写。并且在 ARM 中为了方便批量操作，提供了“！”运算符，可以在指令中加入“！”让系统执行完指令后自动修改指针。这样大大提高了效率。
（4）指令的差异。X86指令和ARM指令都由操作码和操作数两部分组成，X86指令大部分是两个操作数，而ARM指令大部分是3个操作数。X86指令中只有跳转指令可以加条件码，成为条件转移指令，当条件成立，例如运算结果为 0，有进位、有借位、有溢出时实现程序的跳转。其他所有的指令都不能有条件执行，因此，分支、循环结构都要借助于这类条件转移指令实现。这样增加了汇编代码长度和设计难度，同时，也使汇编代码结构性较差。ARM指令所不同的是不仅是跳转指令后可以加条件码，大部分常用的ARM指令后面都可以加条件码，成为有条件执行指令，也就是MOV，ADD，AND这类常用指令后都可以加条件码，这样使 ARM 汇编程序设计更灵活，不需要频繁跳转。同样的功能，ARM汇编需要的指令比 X86 汇编需要的指令更少，结构性更好。
（5）子程序调用差异。X86的子程序定义要用函数伪指令定义，函数之间调用采用 CALL指令，即 CALL子函数名即可，子函数返回使用指令RET。CALL指令的功能是首先保存返回地址到堆栈，然后修改程序计数器为子程序地址，跳转到子程序执行。RET指令的功能就是从堆栈中弹出返回地址给程序计数器，从而回到被调用程序继续往下运行。统一的函数定义及调用方式使代码的可读性较好，但是向程序员掩盖了函数调用和返回的具体细节。ARM 的子程序没有独特的定义格式，函数名只是一个标号（lable）和其他标号没有什么区别，函数调用采用 BL 指令，即 BL 子函数名，子函数返回使用MOV指令，即MOV，PC，LR。BL指令的功能首先保存返回地址到 LR链接寄存器中，然后修改程序计数器 PC，使 CPU 跳去执行子程序的代码。返回指令非常直接，就是将保存的返回地址还给程序计数器PC，使CPU回到被调用程序继续往下执行。
```

### ARM

| 体系架构   | 处理器家族                                    |
| ---------- | --------------------------------------------- |
| ARM v1     | ARM1                                          |
| ARM v2     | ARM2、ARM3                                    |
| ARM v3     | ARM6、ARM600、ARM610、ARM7、ARM700、ARM710    |
| ARM v4     | StrongARM、ARM8、ARM810、ARM7-TDMI、ARM9-TDMI |
| ARM v5     | ARM7EJ、ARM9E、ARM10E、XScale                 |
| ARM v6     | ARM11                                         |
| ARM v7-A/R |                                               |
| ARM v8-A   |                                               |



| 系列                           | 应用                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| Cortex-A（A：Application）     | 针对日益增长的消费娱乐和无线产品设计，用于具有高计算要求、运行丰富操作系统及提供交互媒体和图形体验的应用领域，如智能手机、平板电脑、汽车娱乐系统、数字电视，智能本、电子阅读器、家用网络、家用网关和其他各种产品。 |
| Cortex-R（R：Real-time）       | 针对需要运行实时操作的系统应用，面向如汽车制动系统、动力传动解决方案、大容量存储控制器等深层嵌入式实时应用。 |
| Cortex-M（M：Microcontroller） | 该系列面向微控制器领域，主要针对成本和功耗敏感的应用，如智能测量、人机接口设备、汽车和工业控制系统、家用电器、消费性产品和医疗器械等。 |
| Cortex-SC（SC：SecurCore）     | 主要用于政府安全芯片。                                       |



## ARM指令集分类（状态）

```
大部分的ARM处理器支持ARM指令集和THUMB指令集。ARM处理器有两种状态: ARM状态执行ARM指令，THUMB状态执行THUMB指令

ARM指令集: 32bits(64bits)，每条指令占用32位的存储空间
THUMB指令集: 16bits,每条指令占16位空间

```



## ARM处理器的工作模式

```
经典ARM处理器有7种模式，cortex-A系列有8种


```





### SoC

```
SoC的全称叫做：System-on-a-Chip，中文的的意思就是“把系统都做在一个芯片上”。
SoC上集成了很多手机上最关键的部件，比如CPU、GPU、内存、也就说虽然它在主板上的存在是一个芯片，但是它里边可是由很多部件封装组成的。
SOC：各大厂商买来ARM的授权，得到ARM处理器的源代码，而后自己搞一些外围设备的IP（或者买或者自己设计），组成一个SOC，比如三星的Exynos 4412，华为的麒麟990。
```

### KunPeng920

```
鲲鹏920是目前业界最高性能ARM-based处理器。该处理器采用7nm制造工艺，基于ARM架构授权，由华为公司自主设计完成。通过优化分支预测算法、提升运算单元数量、改进内存子系统架构等一系列微架构设计，大幅提高处理器性能。典型主频下， SPECint Benchmark评分超过930，超出业界标杆25%。同时，能效比优于业界标杆30%。鲲鹏920以更低功耗为数据中心提供更强性能。
```

```
神威太湖之光-Alpha架构的CPU

```

### 移植

```
架构差异：x86 和鲲鹏处理器 (aarch64) 属于不同的架构。
指令集差异：x86– 复杂指令集，鲲鹏处理器 – 精简指令集。
向量寄存器差异：x86 和鲲鹏处理器使用向量寄存器不同，向量指令集也存在差异。

1. 迁移准备：信息收集 & 环境申请

信息的收集主要分为两部分，首先是硬件信息的收集，主要就是一些型号，目的是根据此类信息匹配一个 x86 的服务器；其次是收集软件栈信息，包括操作系统、虚拟机、中间件、编译器、上层依赖的开源软件、商业软件、业务软件等信息。

2. 迁移分析：软件栈分析 & 编程语言分析

这一过程要做的就是对收集到的信息和软件栈做初步分析，目的是判断是否真正需要迁移，评估迁移的工作量。

对开源软件来说，因为社区发展已经比较成熟，迁移相对较为简单，通过基于鲲鹏的架构分支或者鲲鹏支持的软件包，自行安装即可。对于自研软件来讲，情况则较为复杂，如 C、C++ 这类编译型软件，从指令集差异化出发，需要重新编译后才能完成迁移，而 Java、Python 这种解释型的语言，因为其虚拟机如 JDK、PVM 已经把上层的一些跟指令集相关的东西屏蔽掉了，平滑地迁移过去即可。对于商用软件而言，不会公开源码，如果需要迁移，就必须要联系厂家去编译一个鲲鹏的版本，并且完成一系列的适配。

此外像运行环境、虚拟机、编译器和操作系统这些也是要进行替换，但是这些并非需要重新编译，因为在华为云鯤鹏论坛内有软件仓库，可以直接去软件仓库下载由鲲鹏官方所做的经过验证的版本。

3. 编译迁移：代码迁移 & 软件包迁移

编译型的语言，之所以迁移起来比较困难，原因就在于涉及到比较多的迁移点，下面将从代码和软件包两方面进行阐述。

对于对指令集有依赖的代码来说，与 x86 架构相关的，都需要替换成 ARM 架构下的语言；像以 Java、Python 为代表的解释型语言，换一下 JDK 和 PVM 就行了，如果语言中调用了编译型语言，必须把这部分重新编译才可行。对于软件包来说，其迁移与 Java、Python 语言类似，即扫描出来里边的对编译型语言的依赖，把这一部分依赖进行替换即可。

4. 性能调优：性能指标测试 & 性能优化

经过前面几个步骤之后，软件迁移其实就基本完成了，之后要对性能进行调优，主要分为建立基准 、压力测试 、确定瓶颈、 实施优化、 确认效果五个步骤。

首先需要建立调优基准，该基准根据当前的硬件配置、组网、测试模型来做综合评估，以建立合理的条有目标；其次在调优目标建立后，通过压测工具对软件或系统进行加压，在加压过程中暴露性能瓶颈，确定瓶颈之后对瓶颈进行优化；第四，注意在优化过程中要及时记录，因为优化并不一定是正向的，出现负向优化时需要及时回退；最后在优化措施实施完成后，需要重新启动压力测试工具以确认优化效果。

5. 测试与认证：压力测试 & 长稳测试 & 规模商用

调优结束之后，接下来就要把功能运力、长稳运力以及性能运力都跑一遍，达到一个商用的标准，就可以筹备上线了。此外也可以将软件和系统进行鲲鹏展翅认证，其可以扩展应用的软件使用空间并能够加入鲲鹏生态。


```



| 项目                  | 参数说明                               |
| --------------------- | -------------------------------------- |
| Architecture          | ARM v8.2                               |
| Core                  | up to 64                               |
| Typical Frequency     | 2.6 GHz / 3.0 GHz                      |
| Memory                | 8 DDR4 Channels（8通道DDR4内存控制器） |
| Coherent Interconnect | 2S&4S（2路/4路互联）                   |
| I/O                   | PCIe 4.0, CCIX, 100G, SAS/SATA 3.0     |
| Max Power             | 180W                                   |
| Process               | 7nm                                    |

### ROMS

1.ROMS简介

ROMS(Regional Ocean Modeling System)模式是常用区域海洋模拟系统，是一个拥有自由表面、地形跟踪、原始方程等特点的海洋模型，在科学界得到广泛应用。

![](D:\OneDrive\研究生\论文\framework.png)

<center>ROMS海洋模型框架</center>



模式框架运行协定遵循了地球系统建模框架（ESMF）的模型耦合协定，表明使用者在使用 ROMS 模式时，可以选择不同的计算方案，包括有独立的海洋模型，也有与大气 模型，波浪模型，生物地球化学模型以及沉积物模型进行耦合，并考虑河流输入进行计算。ROMS使用的物理和数值算法，包含沉积物、生物光学、生物地球化学和海冰模块，还包括了一些垂直混合方案、多层次的嵌套网格。ROMS包含非线性模块(NLM)、切线性模块(TLM)、代表切线性模块(RPM)和伴随模块(ADM)组成了ROMS的动态内核。这四个模块可以独立计算，也可协同计算。非线性用于模拟预报，其他三个用于模式参数调试，稳定性和同化过程。上图中的传播算子程序( propagator)在广义稳定性理论(GST)中得到广泛应用，用来研究海洋环流的灵敏度、稳定性和动力学，减少预测系统中的误差和不确定性，同时进行自适应采样。伴随敏感性程序(ADSEN)可以用来计算选定的函数模型对物理属性变化的响应。它包括了强(S4DVAR、IS4DVAR) 约束变分数据同化驱动器和弱( W4DVAR)约束变分数据同化驱动器。集合预报程序可利用奇异向量沿着状态空间最不稳定的方向来扰动或初始化条件。最后，完整性检验程序中包含几个驱动程序，可以用来测试NLM、TLM、ADM、RPM算法的正确性和准确性。

2.ROMS 基本控制方程

ROMS 的控制方程是由 Navier-Stokes 原始方程推导而来，在 Boussinesq（布辛尼斯克）假定、流体静力近似以及流体不可压缩假设的前提下，利用有限差分
算法，近似求解 Reynolds-averaged（雷诺平均）下的 Navier-Stokes 方程。考虑右手笛卡尔坐标系，东向为 x 轴正向，北向为 y 轴正向，垂直向上为 z 轴正向。则：

​	描述海水质量守恒的连续性方程：
$$
\frac{ \partial u}{ \partial x}+\frac{ \partial \nu}{ \partial y}+\frac{ \partial w}{ \partial z} = 0
$$
​	描述在$x$方向和$y$方向上运动的动量平衡方程：
$$
\frac{ \partial u}{ \partial t}+\vec{\nu}·\nabla u -f_v=- \frac{ 1}{ \rho_0}\frac{ \partial P}{ \partial x}+F_u+D_u
$$

$$
\frac{ \partial v}{ \partial t}+\vec{\nu}·\nabla v +f_u=- \frac{ 1}{ \rho_0}\frac{ \partial P}{ \partial y}+F_v+D_v
$$

​	标准浓度场（温度和盐度）的对流扩散方程：
$$
\frac{ \partial T}{ \partial t}+\vec{\nu}·\nabla T=F_T+D_T
$$

$$
\frac{ \partial S}{ \partial t}+\vec{\nu}·\nabla S=F_S+D_S
$$

​	海水的状态方程为：
$$
\rho=\rho(T,S,P)
$$
​	Boussinesq 假定下，除了垂直动量方程中密度对浮力的贡献外，动量方程中的密度变化被忽略，在静压近似下，进一步假设垂直压力梯度平衡浮力。其流体的静力平衡方程为：
$$
\rho g=-\frac{ \partial P}{ \partial z}
$$
上述 7 个方程中，其中$\vec{\nu}=(u,v,w)$代表三维流速向量，$\rho$表示水的局地密度，$T$表示海水温度，$S$代表海水盐度，$P$代表海水压力，$\rho_0$为水的参考密度，$f$表示科氏参数，$g$表示重力加速度，$\phi$代表动力压力，$(D_u,D_v,D_T,D_S)$表示对应变量的耗散项，$(𝐹_𝑢,𝐹_𝑣,𝐹_𝑇,𝐹_𝑆)$表示施加的强迫项。

3.网格与 S 坐标系

模式动力部分包含拉伸垂直坐标（S坐标），曲线正交网格，正斜压模态分离。可用于海洋环流，潮汐，海浪，海洋生化过程，海洋泥沙等过程模拟。

垂直网格：
	垂直网格是混合拉伸网格。它是混合的，因为它的拉伸间隔落在以下两个极端之间：

​	1）网格所使用的均匀间隔的sigma网格。 普林斯顿海洋模型。

​	2）具有固定深度间隔的真实z网格。可以挤压或拉伸垂直网格以增加或降低感兴趣区域（例如， 温跃层 或底部边界层。垂直方向上的网格拉伸遵循底部地形，从而使理想的水流在诸如海山等地物上流动。

水平网格：
	水平网格是结构化网格，这意味着它具有矩形的4边网格单元结构。水平网格也是正交的曲线网格，这意味着它会最大化感兴趣的海洋网格单元并最小化额外的陆地网格单元。水平网格也是交错网格或 Arakawa C网格，其中在每个网格单元的边缘计算南北方向和东西方向的速度，而在每个网格单元的中心计算标量变量（例如密度）的值，称为“ rho-points”。

4.ROMS的支撑库

![](D:\OneDrive\研究生\论文\ROMS安装支撑库以及依赖关系png.png)

<center>ROMS安装支撑库以及依赖关系</center>

​	编译器

​		编译器的种类繁多，目前最常用2类，一种为GNU编译套件（gcc，gfortran，g++，一般Linux系统自带）和Intel编译套件（icc，ifort，icpc，商业软件，可申请免费版本）。

​	并行通信库（MPI）

​		并行通信MPI库分成2类，一种为包括Mpich，Mpich2， Openmpi，Mvapich，一种为Intel MPI，一般情况下Mpich，Mpich2，Openmpi，Mvapich和GNU编译套件能完美兼容，而Intel编译套件中自带IntelMPI，无需用户单独安装。所以这里有两套主要的编译方案，一是GNU编译方案（GNU编译器+Mpich，Mpich2，Openmpi，Mvapich任意一个），二是Intel编译方案（intel编译器+IntelMPI），两套编译方案无法兼容，容易引起编译错误。底层的编译器是上层模式支撑库和ROMS模式安装的基础和关键，保持一条原则：自始至终使用一套编译方案。

​	HDF5

​		HDF5需要依赖编译器，并行库，szip和zlib库；

​	NetCDF4

​		NetCDF4需要依赖编译器，并行库，HDF5。NetCDF4在4.1.3版本之后分成C和Fortran 2个版本，所以要安装2个NetCDF4的库；



### 总结

```
目前多数的高性能计算软件都是面向 x86 架构设计开发，提供 ARM架构的应用移植指导比较缺少。借助华为鲲鹏移植套件完成 ROMS 从 x86 到 ARM 的完整移植过程。

为了进一步提高 ROMS 应用移植到 ARM 架构后的性能，研究面向 ARM 架构在硬件和软件层面的优化方法。可以采用 NMON 性能监控工具对程序运行状态的数据进行采集，可视化的展示验证移植并优化后ROMS 的性能。
```











### 
